/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package memories

import java.util.concurrent.ThreadLocalRandom
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger

private val cpuCount = Runtime.getRuntime().availableProcessors()

fun main(args: Array<String>) {
    val allocators = setup()
    waitForStop(allocators)
}


fun setup(): List<Allocator> {
    return (1..6 * cpuCount).map {
        createShortLivedObjectsAllocator(bigArraySize, 13)
    } + (1..cpuCount).map {
        createShortLivedObjectsAllocator(memories.humongousArraySize, 103)
    } + (1..cpuCount).map {
        createLongLivedObjectsAllocator()
    }
}

fun waitForStop(stuffToWait: List<Allocator>) {
    try {
        Thread.sleep(Integer.MAX_VALUE.toLong())
        println(SimpleBlackHole.getValue())
    } catch (_: InterruptedException) {
    }
    stuffToWait.forEach { it.stop() }
    stuffToWait.forEach { it.join() }
}

private val counter = AtomicInteger(0)
private const val sleepTime = 7L

class Allocator(private val sleepTime: Long, private val allocateLoop: () -> Unit) {

    private val stop = AtomicBoolean(false)
    private val thread: Thread

    init {
        val threadName = "Allocator-thread-${counter.incrementAndGet()}"
        thread = Thread {
            while (!stop.get()) {
                allocateLoop()
                try {
                    Thread.sleep(sleepTime)
                } catch (_: InterruptedException) {

                }
            }
        }.apply {
            name = threadName
            isDaemon = true
            start()
        }
    }

    fun stop() {
        stop.set(true)
    }

    fun join() {
        stop()
        thread.join()
    }
}

private val smallArraySize = 23

// Let's use some humongous regions
private val humongousArraySize = 2097152
private val bigArraySize = 65531

fun createShortLivedObjectsAllocator(size: Int, sleepTime: Long): Allocator {
    return Allocator(sleepTime) {
        val bytes = ByteArray(size)
        ThreadLocalRandom.current().nextBytes(bytes)
        SimpleBlackHole.consume(bytes)
    }
}

fun createLongLivedObjectsAllocator(): Allocator {
    val treeLevelSize = 32
    val releaseCycle = 229

    val topLevelInitializer: (Int) -> Array<Array<Array<ByteArray?>>> = {
        Array(treeLevelSize) {
            Array(treeLevelSize) {
                Array(treeLevelSize) {
                    null
                }
            }
        }
    }

    val arr: Array<Array<Array<Array<ByteArray?>>>> = Array(treeLevelSize, topLevelInitializer)
    var loopCounter = 0

    fun forRootArrays(arr: Array<Array<Array<Array<ByteArray?>>>>, arrConsumer: (Array<ByteArray?>) -> Unit) {
        arr.forEach {
            it.forEach {
                it.forEach { maybeByteArrays ->
                    arrConsumer(maybeByteArrays)
                }
            }
        }
    }

    return Allocator(7L) {
        forRootArrays(arr) { arrayOfByteArrays ->
            arrayOfByteArrays.forEachIndexed { index, _ ->
                val bytes = ByteArray(smallArraySize)
                ThreadLocalRandom.current().nextBytes(bytes)
                arrayOfByteArrays[index] = bytes
            }
        }
        forRootArrays(arr) {
            SimpleBlackHole.consume(it)
        }
        if (loopCounter++ == releaseCycle) {
            loopCounter = 0
            arr.forEachIndexed { index, _ ->
                arr[index] = topLevelInitializer(index)
            }
        }
    }
}
